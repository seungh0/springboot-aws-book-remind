# 스프링 부트와 AWS로 혼자 구현하는 웹 서비스

## 2장
### TDD
- 레드 그린 사이클
    - 항상 실패하는 테스트를 먼저 작성하고 (Red)
    - 테스트가 통과하는 프로덕션 코드를 작성하고 (Green)
    - 테스트가 통과하면 프로덕션 코드를 리팩토링한다. (Refactor)

### 단위 테스트
- 기능 단위의 테스트 코드를 작성 하는 것.

- 테스트 코드를 작성해야 하는 이유?
    - 단위 테스트는 개발 단계 초기에 문제를 발견하게 도와준다.
    - 단위 테스트는 개발자가 나중에 코드를 리팩토링하거나 라이브러리 업데이트
    등에서 기존 기능이 올바르게 작동하는지 확인할 수 있다.(회귀 테스트)
    - 단위 테스트는 기능에 대한 불확실성을 감소
    - 단위 테스트는 시스템에 대한 실제 문서를 제공.
   
## 3장
MyBatis, iBatis -> SQL Mapper
JPA -> ORM

### JPA의 소개
- 패러다임의 불일치 문제: 관계형 데이터 베이스 vs 객체지향 프로그래밍 언어
- 관계형 데이터베이스와 객체지향 프로그래밍 언어의 패러다임이 서로 다른데, 객체를 데이터베이스에 저장하려고 하니 여러 문제가 발생하는 것을 의미,
- JPA는 이렇게 서로 지향하는 바가 다른 2개 영역을 중간에서 패러다임 일치를 시켜주는 기술임.
- 개발자는 객체지향적으로 프로그래밍을 하고, JPA가 이를 관계형 데이터베이스에 맞게 SQL을 대신 생성해서 실행.
### Spring Data JPA 
- JPA <- Hibernate <- Spring Data JPA
### 추상화시킨 Spring Data JPA 모듈을 사용해서 JPA 기술을 다루면 이점
- 구현체 교체의 용이성 (Hibernate 외에 다른 구현체로 쉽게 교체 가능)
- 저장 교체의 용이성 (관계형 데이터베이스 외에 다른 저장소로 쉽게 교체하기 위함)

### 도메인
- 소프트웨어에 대한 요구사항 혹은 문제 영역.
  
### Entity의 PK를 Long 타입의 Auto_increment를 추천하는 이유
(비즈니스 상 유니크 키나, 여러 키를 조합한 복합키로 PK를 잡을 경우 문제점)
- FK를 맺을 때 다른 테이블에서 복합키 전부를 갖고 있거나, 중간 테이블을 하나 더 둬야 하는 상황 발생
- 인덱스에 좋은 영향을 끼치지 못함.
- 유니크한 조건이 변경될 경우 PK 전체를 수정해야하는 일이 발생.

### Service 계층의 역할
- 트랜잭션, 도메인 간 순서 보장의 역할 수행
- 비지니스 로직 처리 X

### Spring Layer
- Web Layer
    - 외부 요청과 응답에 대한 전반적인 영역
- Service Layer
    - 위에 설명
- Repository Layer
    - Database와 같이 데이터 저장소에 접근하는 영역
- Dtos
    - 계층 간에 데이터 교환을 위한 객체
- Domain Layer
    - 개발 대상을 모든 사람이 동일한 관점에서 이해할 수 있고 공유할 수 있도록 단순화시킨것 = 도메인 모델
    
### 스프링에서 Bean을 주입받는 방식
- @Autowired
- setter
- 생성자 (가장 권장)

### 롬복 사용 이유
- 해당 클래스의 의존성 관계가 변경될 때마다 생성자 코드를 계속해서 수정하는 번거러움을 해결하기 위함.

### Entity 클래스를 Request/Response 클래스로 사용하면 안되는 이유
- Entity 클래스는 데이터베이스와 맞닿은 핵심 클래스이다.
- View Layer와 DB Layer의 역할 분리를 철저하게 하는 것이 좋음.

## Date, Calendar 클래스의 문제점
- 불변 객체가 아님 => 멀티 스레드 환경에서 문제 발생 가능
- Calendar은 월 값 설계까 잘못 되었음.

## 4장
### 조회용 프레임워크
- querydsl, jooq, MyBatis
- FK의 조인, 복잡한 조건 등으로 인해 이런 Entity 클래스만으로 처리하기 어려워
조회용 프레임워크를 추가로 사용
- 등록/수정/삭제는 Spring Data JPA, 조회는 querydsl

## 5장
### 엔티티 클래스를 직렬화하면 안되는 이유
- 언제 다른 엔티티와 관계가 형성될지 모른다.
- 직렬화 대상에 자식들 까지 포함되니 성능 이슈, 부수 효과가 발생할 확률이 높음.
- 따라서 직렬화 기능을 가진 세션 Dto를 하나 추가로 만드는 것이 좋음.

### 세션 저장소
- 톰켓 세션 사용
    톰켓에 세션이 저장되기 때문에 2대 이상의 WAS가 구동되는 환경에서는 톰켓들 간의 세션 공유를 위한 추가 설정 필요.
- MySQL과 같은 데이터베이스를 세션 저장소로 사용
    - 여러 WAS 간의 공용 세션을 사용할 수 있는 가장 쉬운 방법
    - 로그인 요청마다 DB IO가 발생하여 성능상 이슈가 발생할 수 있음.
    - 보통 로그인 요청이 많이 없는 백오피스, 사내 시스템 용도로 사용
- Redis, Memcached와 같은 메모리 DB를 세션 저장소로 사용
    - B2C 서비스에서 가장 많이 사용하는 방식
    - 실제 서비스로 사용하기 위해서는 Embedded Redis와 같은 방식이 아닌 외부 메모리 서버가 필요.
